// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.11.4
// source: foodiLBS.proto

package foodi_lbs_server

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Geo_GeoAdd_FullMethodName           = "/foodiLBS.geo/GeoAdd"
	Geo_GeoPosition_FullMethodName      = "/foodiLBS.geo/GeoPosition"
	Geo_GeoHash_FullMethodName          = "/foodiLBS.geo/GeoHash"
	Geo_GeoDist_FullMethodName          = "/foodiLBS.geo/GeoDist"
	Geo_RadioOrder_FullMethodName       = "/foodiLBS.geo/RadioOrder"
	Geo_RadioOrderStore_FullMethodName  = "/foodiLBS.geo/RadioOrderStore"
	Geo_RadioMember_FullMethodName      = "/foodiLBS.geo/RadioMember"
	Geo_RadioMemberStore_FullMethodName = "/foodiLBS.geo/RadioMemberStore"
)

// GeoClient is the client API for Geo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GeoClient interface {
	GeoAdd(ctx context.Context, in *GeoAddRequest, opts ...grpc.CallOption) (*GeoAddReply, error)
	GeoPosition(ctx context.Context, in *PositionRequest, opts ...grpc.CallOption) (*PositionReply, error)
	GeoHash(ctx context.Context, in *HashRequest, opts ...grpc.CallOption) (*HashReply, error)
	GeoDist(ctx context.Context, in *DistRequest, opts ...grpc.CallOption) (*DistReply, error)
	RadioOrder(ctx context.Context, in *RadioOrderRequest, opts ...grpc.CallOption) (*RadioOrderReply, error)
	RadioOrderStore(ctx context.Context, in *RadioOrderStoreRequest, opts ...grpc.CallOption) (*RadioOrderReply, error)
	RadioMember(ctx context.Context, in *RadioMemberRequest, opts ...grpc.CallOption) (*RadioOrderReply, error)
	RadioMemberStore(ctx context.Context, in *RadioMemberStoreRequest, opts ...grpc.CallOption) (*RadioOrderReply, error)
}

type geoClient struct {
	cc grpc.ClientConnInterface
}

func NewGeoClient(cc grpc.ClientConnInterface) GeoClient {
	return &geoClient{cc}
}

func (c *geoClient) GeoAdd(ctx context.Context, in *GeoAddRequest, opts ...grpc.CallOption) (*GeoAddReply, error) {
	out := new(GeoAddReply)
	err := c.cc.Invoke(ctx, Geo_GeoAdd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) GeoPosition(ctx context.Context, in *PositionRequest, opts ...grpc.CallOption) (*PositionReply, error) {
	out := new(PositionReply)
	err := c.cc.Invoke(ctx, Geo_GeoPosition_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) GeoHash(ctx context.Context, in *HashRequest, opts ...grpc.CallOption) (*HashReply, error) {
	out := new(HashReply)
	err := c.cc.Invoke(ctx, Geo_GeoHash_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) GeoDist(ctx context.Context, in *DistRequest, opts ...grpc.CallOption) (*DistReply, error) {
	out := new(DistReply)
	err := c.cc.Invoke(ctx, Geo_GeoDist_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) RadioOrder(ctx context.Context, in *RadioOrderRequest, opts ...grpc.CallOption) (*RadioOrderReply, error) {
	out := new(RadioOrderReply)
	err := c.cc.Invoke(ctx, Geo_RadioOrder_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) RadioOrderStore(ctx context.Context, in *RadioOrderStoreRequest, opts ...grpc.CallOption) (*RadioOrderReply, error) {
	out := new(RadioOrderReply)
	err := c.cc.Invoke(ctx, Geo_RadioOrderStore_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) RadioMember(ctx context.Context, in *RadioMemberRequest, opts ...grpc.CallOption) (*RadioOrderReply, error) {
	out := new(RadioOrderReply)
	err := c.cc.Invoke(ctx, Geo_RadioMember_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoClient) RadioMemberStore(ctx context.Context, in *RadioMemberStoreRequest, opts ...grpc.CallOption) (*RadioOrderReply, error) {
	out := new(RadioOrderReply)
	err := c.cc.Invoke(ctx, Geo_RadioMemberStore_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeoServer is the server API for Geo service.
// All implementations must embed UnimplementedGeoServer
// for forward compatibility
type GeoServer interface {
	GeoAdd(context.Context, *GeoAddRequest) (*GeoAddReply, error)
	GeoPosition(context.Context, *PositionRequest) (*PositionReply, error)
	GeoHash(context.Context, *HashRequest) (*HashReply, error)
	GeoDist(context.Context, *DistRequest) (*DistReply, error)
	RadioOrder(context.Context, *RadioOrderRequest) (*RadioOrderReply, error)
	RadioOrderStore(context.Context, *RadioOrderStoreRequest) (*RadioOrderReply, error)
	RadioMember(context.Context, *RadioMemberRequest) (*RadioOrderReply, error)
	RadioMemberStore(context.Context, *RadioMemberStoreRequest) (*RadioOrderReply, error)
	mustEmbedUnimplementedGeoServer()
}

// UnimplementedGeoServer must be embedded to have forward compatible implementations.
type UnimplementedGeoServer struct {
}

func (UnimplementedGeoServer) GeoAdd(context.Context, *GeoAddRequest) (*GeoAddReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GeoAdd not implemented")
}
func (UnimplementedGeoServer) GeoPosition(context.Context, *PositionRequest) (*PositionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GeoPosition not implemented")
}
func (UnimplementedGeoServer) GeoHash(context.Context, *HashRequest) (*HashReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GeoHash not implemented")
}
func (UnimplementedGeoServer) GeoDist(context.Context, *DistRequest) (*DistReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GeoDist not implemented")
}
func (UnimplementedGeoServer) RadioOrder(context.Context, *RadioOrderRequest) (*RadioOrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RadioOrder not implemented")
}
func (UnimplementedGeoServer) RadioOrderStore(context.Context, *RadioOrderStoreRequest) (*RadioOrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RadioOrderStore not implemented")
}
func (UnimplementedGeoServer) RadioMember(context.Context, *RadioMemberRequest) (*RadioOrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RadioMember not implemented")
}
func (UnimplementedGeoServer) RadioMemberStore(context.Context, *RadioMemberStoreRequest) (*RadioOrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RadioMemberStore not implemented")
}
func (UnimplementedGeoServer) mustEmbedUnimplementedGeoServer() {}

// UnsafeGeoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeoServer will
// result in compilation errors.
type UnsafeGeoServer interface {
	mustEmbedUnimplementedGeoServer()
}

func RegisterGeoServer(s grpc.ServiceRegistrar, srv GeoServer) {
	s.RegisterService(&Geo_ServiceDesc, srv)
}

func _Geo_GeoAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeoAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).GeoAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_GeoAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).GeoAdd(ctx, req.(*GeoAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_GeoPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).GeoPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_GeoPosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).GeoPosition(ctx, req.(*PositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_GeoHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).GeoHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_GeoHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).GeoHash(ctx, req.(*HashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_GeoDist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).GeoDist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_GeoDist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).GeoDist(ctx, req.(*DistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_RadioOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RadioOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).RadioOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_RadioOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).RadioOrder(ctx, req.(*RadioOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_RadioOrderStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RadioOrderStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).RadioOrderStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_RadioOrderStore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).RadioOrderStore(ctx, req.(*RadioOrderStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_RadioMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RadioMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).RadioMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_RadioMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).RadioMember(ctx, req.(*RadioMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Geo_RadioMemberStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RadioMemberStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoServer).RadioMemberStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Geo_RadioMemberStore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoServer).RadioMemberStore(ctx, req.(*RadioMemberStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Geo_ServiceDesc is the grpc.ServiceDesc for Geo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Geo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foodiLBS.geo",
	HandlerType: (*GeoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GeoAdd",
			Handler:    _Geo_GeoAdd_Handler,
		},
		{
			MethodName: "GeoPosition",
			Handler:    _Geo_GeoPosition_Handler,
		},
		{
			MethodName: "GeoHash",
			Handler:    _Geo_GeoHash_Handler,
		},
		{
			MethodName: "GeoDist",
			Handler:    _Geo_GeoDist_Handler,
		},
		{
			MethodName: "RadioOrder",
			Handler:    _Geo_RadioOrder_Handler,
		},
		{
			MethodName: "RadioOrderStore",
			Handler:    _Geo_RadioOrderStore_Handler,
		},
		{
			MethodName: "RadioMember",
			Handler:    _Geo_RadioMember_Handler,
		},
		{
			MethodName: "RadioMemberStore",
			Handler:    _Geo_RadioMemberStore_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foodiLBS.proto",
}

const (
	Delivery_Demo_FullMethodName = "/foodiLBS.delivery/Demo"
)

// DeliveryClient is the client API for Delivery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeliveryClient interface {
	Demo(ctx context.Context, in *DeliverDemoRequest, opts ...grpc.CallOption) (*DeliverDemoReply, error)
}

type deliveryClient struct {
	cc grpc.ClientConnInterface
}

func NewDeliveryClient(cc grpc.ClientConnInterface) DeliveryClient {
	return &deliveryClient{cc}
}

func (c *deliveryClient) Demo(ctx context.Context, in *DeliverDemoRequest, opts ...grpc.CallOption) (*DeliverDemoReply, error) {
	out := new(DeliverDemoReply)
	err := c.cc.Invoke(ctx, Delivery_Demo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeliveryServer is the server API for Delivery service.
// All implementations must embed UnimplementedDeliveryServer
// for forward compatibility
type DeliveryServer interface {
	Demo(context.Context, *DeliverDemoRequest) (*DeliverDemoReply, error)
	mustEmbedUnimplementedDeliveryServer()
}

// UnimplementedDeliveryServer must be embedded to have forward compatible implementations.
type UnimplementedDeliveryServer struct {
}

func (UnimplementedDeliveryServer) Demo(context.Context, *DeliverDemoRequest) (*DeliverDemoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Demo not implemented")
}
func (UnimplementedDeliveryServer) mustEmbedUnimplementedDeliveryServer() {}

// UnsafeDeliveryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeliveryServer will
// result in compilation errors.
type UnsafeDeliveryServer interface {
	mustEmbedUnimplementedDeliveryServer()
}

func RegisterDeliveryServer(s grpc.ServiceRegistrar, srv DeliveryServer) {
	s.RegisterService(&Delivery_ServiceDesc, srv)
}

func _Delivery_Demo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeliverDemoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeliveryServer).Demo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Delivery_Demo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeliveryServer).Demo(ctx, req.(*DeliverDemoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Delivery_ServiceDesc is the grpc.ServiceDesc for Delivery service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Delivery_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "foodiLBS.delivery",
	HandlerType: (*DeliveryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Demo",
			Handler:    _Delivery_Demo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "foodiLBS.proto",
}
